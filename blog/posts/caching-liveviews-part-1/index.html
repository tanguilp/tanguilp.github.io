<!DOCTYPE html>
<html><head lang="en">
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Caching Liveviews - Part 1: The road to HTTP-caching Liveviews - Tangui&#39;s blog</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="Since I release of HTTP caching libraries for Elixir and
particularly plug_http_cache, the most
frequent question has been if it&rsquo;s possible to cache Liveviews.
Why caching Liveviews
The first reason is SEO, that is to speed up page loading to get a better page ranking. Search
engines take into account many parameters, including the Time To First Byte which is why caching is
important for some Phoenix apps. Although you can theoretically develop some pages with Liveview
(not cacheable until today) and some others, with no interactive, in plain old Phoenix views
(cacheable - but they&rsquo;ll never have Liveview&rsquo;s interactivity), developers tend to choose only one
option. I&rsquo;ve heard that the lack of cacheability has been a obstacle to adopting Liveview in some
projects." />
	<meta property="og:image" content=""/>
	<meta property="og:url" content="https://svground.fr/blog/posts/caching-liveviews-part-1/">
  <meta property="og:site_name" content="Tangui&#39;s blog">
  <meta property="og:title" content="Caching Liveviews - Part 1: The road to HTTP-caching Liveviews">
  <meta property="og:description" content="Since I release of HTTP caching libraries for Elixir and particularly plug_http_cache, the most frequent question has been if itâ€™s possible to cache Liveviews.
Why caching Liveviews The first reason is SEO, that is to speed up page loading to get a better page ranking. Search engines take into account many parameters, including the Time To First Byte which is why caching is important for some Phoenix apps. Although you can theoretically develop some pages with Liveview (not cacheable until today) and some others, with no interactive, in plain old Phoenix views (cacheable - but theyâ€™ll never have Liveviewâ€™s interactivity), developers tend to choose only one option. Iâ€™ve heard that the lack of cacheability has been a obstacle to adopting Liveview in some projects.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-31T13:04:22+01:00">
    <meta property="article:modified_time" content="2024-08-31T13:04:22+01:00">
    <meta property="article:tag" content="HTTP Caching">
    <meta property="article:tag" content="Elixir">
    <meta property="article:tag" content="Liveview">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Caching Liveviews - Part 1: The road to HTTP-caching Liveviews">
  <meta name="twitter:description" content="Since I release of HTTP caching libraries for Elixir and particularly plug_http_cache, the most frequent question has been if itâ€™s possible to cache Liveviews.
Why caching Liveviews The first reason is SEO, that is to speed up page loading to get a better page ranking. Search engines take into account many parameters, including the Time To First Byte which is why caching is important for some Phoenix apps. Although you can theoretically develop some pages with Liveview (not cacheable until today) and some others, with no interactive, in plain old Phoenix views (cacheable - but theyâ€™ll never have Liveviewâ€™s interactivity), developers tend to choose only one option. Iâ€™ve heard that the lack of cacheability has been a obstacle to adopting Liveview in some projects.">
<script src="../../js/feather.min.js"></script>
	
	
        <link href="../../css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="../../css/main.5cebd7d4fb2b97856af8d32a6def16164fcf7d844e98e236fcb3559655020373.css" />

	
	

	
	

	
		
		
		<link rel="stylesheet" type="text/css" href="../../css/custom.d287809400cafea254e83ff2007e8eae4bcba882165ffd064d74d2483d34b156.css">
		
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="../../../index.html">Tangui&#39;s blog</a>
	</div>
	<nav>
		
		<a href="../../index.html">Home</a>
		
		<a href="../../posts.html">All posts</a>
		
		<a href="../../about.html">About</a>
		
		<a href="../../tags.html">Tags</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">Caching Liveviews - Part 1: The road to HTTP-caching Liveviews</h1>
			<div class="meta">Posted on Aug 31, 2024</div>
		</div>
		

		

		<section class="body">
			<p>Since I release of <a href="../introducing-http-cache/index.html">HTTP caching libraries</a> for Elixir and
particularly <a href="https://hex.pm/packages/plug_http_cache"><code>plug_http_cache</code></a>, the most
frequent question has been if it&rsquo;s possible to cache Liveviews.</p>
<h2 id="why-caching-liveviews">Why caching Liveviews</h2>
<p>The first reason is <strong>SEO</strong>, that is to speed up page loading to get a better page ranking. Search
engines take into account many parameters, including the Time To First Byte which is why caching is
important for some Phoenix apps. Although you can theoretically develop some pages with Liveview
(not cacheable until today) and some others, with no interactive, in plain old Phoenix views
(cacheable - but they&rsquo;ll never have Liveview&rsquo;s interactivity), developers tend to choose only one
option. I&rsquo;ve heard that the lack of cacheability has been a obstacle to adopting Liveview in some
projects.</p>
<p>The second reason is <strong>performance</strong> and is due to how Liveview works. The page is rendered twice:</p>
<ul>
<li>first mount, that we&rsquo;ll call <em>static mount</em>, renders a static plain HTML page and sends it to the
browser</li>
<li>the returned page includes Liveview&rsquo;s javascript code, that initiates the second mount through
a newly established websocket. Let&rsquo;s call it the <em>live mount</em></li>
</ul>
<p>That is the second mount, the <em>live mount</em>, that enables interactivity by sending updates
on the wire over time. However, the <em>live mount</em> also executes the same, initial rendering
performed by the <em>static mount</em>.</p>
<p>For instance, if you&rsquo;re showing a product page and are loading the first 20 products, then your
Liveview will actually load these 20 products twice. Caching the first rendering, the <em>static mount</em>,
allows saving ~50% of DB requests on these pages.</p>
<h2 id="enabling-plug_http_cache-on-liveviews">Enabling <code>plug_http_cache</code> on Liveviews</h2>
<p>What if we try to enable <code>plug_http_cache</code> for Liveviews? Let&rsquo;s try with the following configuration:</p>
<p><code>project_web/router.ex</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-elixir" data-lang="elixir"><span style="display:flex;"><span>  pipeline <span style="color:#e6db74">:caching</span> <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>    plug <span style="color:#a6e22e">PlugCacheControl</span>, <span style="color:#e6db74">directives</span>: [<span style="color:#e6db74">:public</span>, <span style="color:#e6db74">s_maxage</span>: {<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">:hour</span>}]
</span></span><span style="display:flex;"><span>    plug <span style="color:#a6e22e">PlugHTTPCache</span>, <span style="color:#a6e22e">@caching_opts</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># ...</span>
</span></span><span style="display:flex;"><span>  scope <span style="color:#e6db74">&#34;/&#34;</span>, <span style="color:#a6e22e">ProjectWeb</span> <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>    pipe_through <span style="color:#e6db74">:browser</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    live_session <span style="color:#e6db74">:default</span> <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>      pipe_through <span style="color:#e6db74">:caching</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      live <span style="color:#e6db74">&#34;/&#34;</span>, <span style="color:#a6e22e">MainLive.Index</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>Then let&rsquo;s refresh the page to check if the page is cached:</p>
<p><img src="../../images/caching_lv_first_attempt.png#center" alt="First attempt at caching Liveviews"></p>
<p>The <code>age</code> header shows our Phoenix app that we&rsquo;ve crafted for the sake of this experiment has
returned the cached page.</p>
<p>Hurray! Too good to be true, right? Yes.</p>
<p>When trying in another browser, simulating another user, the page keeps reloading with the following
exception:</p>
<pre tabindex="0"><code>[debug] LiveView session was misconfigured or the user token is outdated.

1) Ensure your session configuration in your endpoint is in a module attribute:

    @session_options [
      ...
    ]

2) Change the `plug Plug.Session` to use said attribute:

    plug Plug.Session, @session_options

3) Also pass the `@session_options` to your LiveView socket:

    socket &#34;/live&#34;, Phoenix.LiveView.Socket,
      websocket: [connect_info: [session: @session_options]]

4) Ensure the `protect_from_forgery` plug is in your router pipeline:

    plug :protect_from_forgery

5) Define the CSRF meta tag inside the `&lt;head&gt;` tag in your layout:

    &lt;meta name=&#34;csrf-token&#34; content={Plug.CSRFProtection.get_csrf_token()} /&gt;

6) Pass it forward in your app.js:

    let csrfToken = document.querySelector(&#34;meta[name=&#39;csrf-token&#39;]&#34;).getAttribute(&#34;content&#34;);
    let liveSocket = new LiveSocket(&#34;/live&#34;, Socket, {params: {_csrf_token: csrfToken}});
</code></pre><p>despite the fact that all of this is correctly configured.</p>
<p>Digging further, it turns out that the CSRF check fails. When setting up the websocket connection,
Phoenix checks that the CSRF token embedded in the page rendered during the <em>static mount</em> (5th item
in the error message above) matches with the CSRF value stored in the user&rsquo;s cookie.</p>
<p>(Note that when Liveview is configured without a session, <code>plug_http_cache</code> works out of the box as
the session is not retrieved and the CSRF check not performed.)</p>
<p>However, we want to serve a page generated for user A, with a CSRF token generated exclusively for
user A, to user B. It cannot work as the CSRF verification value stored in the cookie will is
different for user B.</p>
<p>Can we get rid of the CSRF token check? That&rsquo;s a security mechanism after all, usually we avoid
removing them whatever the reason.</p>
<h2 id="csrf--cswsh">CSRF &amp; CSWSH</h2>
<p>Phoenix makes use of CSRF tokens to protect against CSRF attacks. I&rsquo;ll assume the reader knows what
a CSRF attack is (there&rsquo;s plenty of resources if not).</p>
<p>Phoenix&rsquo;s forms
<a href="https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#form/1-csrf-protection">automatically protects</a>
forms with a CSRF token. The <code>plug :protect_from_forgery</code> is installed by default in the browser
pipeline in Phoenix&rsquo;s router.</p>
<p>Last years, CSRF attacks have largely been mitigated by the new <code>SameSite</code> cookie attribute. When a
cookie is set to <code>Lax</code> or <code>Strict</code>, it prevents most CSRF attacks from happening because cookies
(and thus authentication cookies) are not longer sent from domains other than yours.</p>
<p>For instance, <code>evil.com</code> cannot use XHR to fetch authenticated content from your site -
authentication cookies are discarded.</p>
<p>All major browsers now implement it and default to sane values (<code>Lax</code>).</p>
<p>Except it doesn&rsquo;t apply to WebSockets, as explained in this
<a href="https://christian-schneider.net/blog/cross-site-websocket-hijacking/">article</a>. When initiating
a <code>ws</code> or <code>wss</code> request, the browsers send all the cookies, ignoring the <code>SameSite</code> cookie
attribute. The article gives the following example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-http" data-lang="http"><span style="display:flex;"><span><span style="color:#a6e22e">GET</span> /trading/ws/stockPortfolio <span style="color:#66d9ef">HTTP</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1.1</span>
</span></span><span style="display:flex;"><span>Host<span style="color:#f92672">:</span> <span style="color:#ae81ff">www.some-trading-application.com</span>
</span></span><span style="display:flex;"><span>User-Agent<span style="color:#f92672">:</span> <span style="color:#ae81ff">Mozilla/5.0 (Macintosh; Intel Mac OS X 10.8; rv:23.0) Firefox/23.0</span>
</span></span><span style="display:flex;"><span>Accept<span style="color:#f92672">:</span> <span style="color:#ae81ff">text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span>
</span></span><span style="display:flex;"><span>Accept-Language<span style="color:#f92672">:</span> <span style="color:#ae81ff">de-de,de;q=0.8,en-us;q=0.5,en;q=0.3</span>
</span></span><span style="display:flex;"><span>Accept-Encoding<span style="color:#f92672">:</span> <span style="color:#ae81ff">gzip, deflate</span>
</span></span><span style="display:flex;"><span>DNT<span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>Sec-WebSocket-Version<span style="color:#f92672">:</span> <span style="color:#ae81ff">13</span>
</span></span><span style="display:flex;"><span>Origin<span style="color:#f92672">:</span> <span style="color:#ae81ff">https://www.some-evil-attacker-application.com</span>
</span></span><span style="display:flex;"><span>Sec-WebSocket-Key<span style="color:#f92672">:</span> <span style="color:#ae81ff">hP+ghc+KuZT2wQgRRikjBw==</span>
</span></span><span style="display:flex;"><span>Cookie<span style="color:#f92672">:</span> <span style="color:#ae81ff">JSESSIONID=1A9431CF043F851E0356F5837845B2EC</span>
</span></span><span style="display:flex;"><span>Connection<span style="color:#f92672">:</span> <span style="color:#ae81ff">keep-alive, Upgrade</span>
</span></span><span style="display:flex;"><span>Pragma<span style="color:#f92672">:</span> <span style="color:#ae81ff">no-cache</span>
</span></span><span style="display:flex;"><span>Cache-Control<span style="color:#f92672">:</span> <span style="color:#ae81ff">no-cache</span>
</span></span><span style="display:flex;"><span>Upgrade<span style="color:#f92672">:</span> <span style="color:#ae81ff">websocket</span>
</span></span></code></pre></div><p>Notice that:</p>
<ul>
<li>the cookie is sent</li>
<li>the origin is <code>https://www.some-evil-attacker-application.com</code></li>
</ul>
<p>Unless the Websocket doesn&rsquo;t allow any user interaction and doesn&rsquo;t expose private information, any
website can send messages and retrieve user private data exposed but the Websocket or worse
(performing destructive operationsâ€¦). This is what is called a Cross-Site WebSocket Hijacking
attack, or CSWSH.</p>
<p>In the context of Phoenix&rsquo;s Liveview, we need to make sure that the Websocket originates from us.
There&rsquo;s 2 ways to deal with it:</p>
<ul>
<li>use A CSRF token</li>
<li>check the <code>origin</code> header</li>
</ul>
<p>Phoenix does both, and allows disabling <code>origin</code> check at your own perils. CRSF token check is,
however, hard-coded in Phoenix&rsquo; socket session setup code.</p>
<p>I believe that checking the <code>origin</code> header is sufficient from a security point of view, but I&rsquo;d be
glad to have confirmation from the community. Until that, don&rsquo;t deploy this into production unless
you trust my security analysis skills!</p>
<p>The <a href="https://datatracker.ietf.org/doc/html/rfc6455#section-10.2">WebSocket RFC</a> doesn&rsquo;t say
otherwise:</p>
<blockquote>
<p>Servers that are not intended to process input from any web page but
only for certain sites SHOULD verify the |Origin| field is an origin
they expect.  If the origin indicated is unacceptable to the server,
then it SHOULD respond to the WebSocket handshake with a reply
containing HTTP 403 Forbidden status code.</p>
</blockquote>
<p>So let&rsquo;s try to disable CSRF check.</p>
<h2 id="disabling-csrf-check">Disabling CSRF check</h2>
<p>The change consist in adding an option to disable CSRF check in Phoenix. The change are hosted
on the <code>feat-socket-optionnal-csrf-check</code> branch of my Phoenix
<a href="https://github.com/tanguilp/phoenix/tree/feat-socket-optionnal-csrf-check">fork</a>. The core of the
changes take a few lines:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span>diff --git a/lib/phoenix/socket/transport.ex b/lib/phoenix/socket/transport.ex
</span></span><span style="display:flex;"><span>index a1c5fd54..2c924cdc 100644
</span></span><span style="display:flex;"><span><span style="color:#f92672">--- a/lib/phoenix/socket/transport.ex
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+++ b/lib/phoenix/socket/transport.ex
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span><span style="color:#75715e">@@ -489,13 +489,10 @@ defmodule Phoenix.Socket.Transport do
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   defp connect_session(conn, endpoint, {key, store, {csrf_token_key, init}}) do
</span></span><span style="display:flex;"><span>     conn = Plug.Conn.fetch_cookies(conn)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">-    with csrf_token when is_binary(csrf_token) &lt;- conn.params[&#34;_csrf_token&#34;],
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-         cookie when is_binary(cookie) &lt;- conn.cookies[key],
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+    with cookie when is_binary(cookie) &lt;- conn.cookies[key],
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>          conn = put_in(conn.secret_key_base, endpoint.config(:secret_key_base)),
</span></span><span style="display:flex;"><span>          {_, session} &lt;- store.get(conn, cookie, init),
</span></span><span style="display:flex;"><span><span style="color:#f92672">-         csrf_state when is_binary(csrf_state) &lt;-
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-           Plug.CSRFProtection.dump_state_from_session(session[csrf_token_key]),
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-         true &lt;- Plug.CSRFProtection.valid_state_and_csrf_token?(csrf_state, csrf_token) do
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+         true &lt;- maybe_check_csrf(conn, endpoint, session, csrf_token_key) do
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>       session
</span></span><span style="display:flex;"><span>     else
</span></span><span style="display:flex;"><span>       _ -&gt; nil
</span></span><span style="display:flex;"><span><span style="color:#75715e">@@ -542,6 +539,18 @@ defmodule Phoenix.Socket.Transport do
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     end
</span></span><span style="display:flex;"><span>   end
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">+  defp maybe_check_csrf(conn, endpoint, session, csrf_token_key) do
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+    if endpoint.config(:socket_check_csrf, true) do
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+      with csrf_token when is_binary(csrf_token) &lt;- conn.params[&#34;_csrf_token&#34;],
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+           csrf_state when is_binary(csrf_state) &lt;-
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+             Plug.CSRFProtection.dump_state_from_session(session[csrf_token_key]) do
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+         Plug.CSRFProtection.valid_state_and_csrf_token?(csrf_state, csrf_token)
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+      end
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+    else
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+      true
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+    end
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+  end
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>   defp check_origin_config(handler, endpoint, opts) do
</span></span><span style="display:flex;"><span>     Phoenix.Config.cache(endpoint, {:check_origin, handler}, fn _ -&gt;
</span></span><span style="display:flex;"><span>       check_origin =
</span></span></code></pre></div><p>and adding the <code>socket_check_csrf</code> endpoint option.</p>
<p>Once you disable CSRF check, <code>origin</code> verification is the only security measure that protects you
from epic failure in the form of leaking your client&rsquo;s data, so be extra careful!</p>
<p>This change is not integrated in Phoenix, work on it will follow this post. Until then, I&rsquo;d
recommend you maintain your own fork of <code>phoenix</code> after cherry-picking this commit, if you want
to enable caching Liveviews.</p>
<h2 id="configuring-plug_http_cache-for-liveview">Configuring <code>plug_http_cache</code> for Liveview</h2>
<p>Back to our sample project, that we&rsquo;ll call <code>CacheableLiveviews</code> from now on, we&rsquo;ll setup HTTP
caching for Liveviews</p>
<p><del>First we need to setup the forked Phoenix:</del></p>
<p><del><code>mix.exs</code></del></p>
<pre tabindex="0"><code class="language-elixir_deprecated" data-lang="elixir_deprecated">  defp deps do
    [
      {:phoenix,
       github: &#34;tanguilp/phoenix&#34;, branch: &#34;feat-socket-optionnal-csrf-check&#34;, override: true},
      # remaining deps
    ]
  end
</code></pre><p><del>and use the new <code>socket_check_csrf</code> option to <code>false</code>:</del></p>
<p><del><code>config.exs</code></del></p>
<pre tabindex="0"><code class="language-elixir_deprecated" data-lang="elixir_deprecated">config :project, Project.Endpoint,
  url: [host: &#34;localhost&#34;],
  adapter: Phoenix.Endpoint.Cowboy2Adapter,
  # ...
  socket_check_csrf: false
</code></pre><p><strong>[Update]</strong> <a href="https://github.com/phoenixframework/phoenix/pull/5952">The required changes</a> have been
merge into Phoenix and the implementation is a bit different that initially designed.</p>
<p>Until Phoenix is 1.7.15 is released, we need to add the Phoenix dependency from Github:</p>
<p><code>mix.exs</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-elixir" data-lang="elixir"><span style="display:flex;"><span>  <span style="color:#66d9ef">defp</span> deps <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>    [
</span></span><span style="display:flex;"><span>      {<span style="color:#e6db74">:phoenix</span>, <span style="color:#e6db74">github</span>: <span style="color:#e6db74">&#34;phoenixframework/phoenix&#34;</span>, <span style="color:#e6db74">override</span>: <span style="color:#66d9ef">true</span>},
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># remaining deps</span>
</span></span><span style="display:flex;"><span>    ]
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>and use the new <code>:check_csrf</code> option in your transports:</p>
<p><code>lib/cacheable_liveviews_web/endpoint.ex</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-elixir" data-lang="elixir"><span style="display:flex;"><span>  socket <span style="color:#e6db74">&#34;/live&#34;</span>, <span style="color:#a6e22e">Phoenix.LiveView.Socket</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">websocket</span>: [<span style="color:#e6db74">connect_info</span>: [<span style="color:#e6db74">session</span>: <span style="color:#a6e22e">@session_options</span>], <span style="color:#e6db74">check_csrf</span>: <span style="color:#66d9ef">false</span>],
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">longpoll</span>: [<span style="color:#e6db74">connect_info</span>: [<span style="color:#e6db74">session</span>: <span style="color:#a6e22e">@session_options</span>], <span style="color:#e6db74">check_csrf</span>: <span style="color:#66d9ef">false</span>]
</span></span></code></pre></div><p>Note that <code>:check_origin</code> must be set to <code>true</code> in your endpoint config, otherwise Phoenix
will not start (yes, even in dev). This is for your own safety.</p>
<p><strong>[End of update]</strong></p>
<p>Then we delete the logic of getting the CSRF token in the Phoenix&rsquo;s javascript - we no longer use
it for this purpose:</p>
<p><code>assets/js/app.js</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="color:#f92672">-let csrfToken = document.querySelector(&#34;meta[name=&#39;csrf-token&#39;]&#34;).getAttribute(&#34;content&#34;)
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-let liveSocket = new LiveSocket(&#34;/live&#34;, Socket, {
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-  longPollFallbackMs: 2500,
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-  params: {_csrf_token: csrfToken}
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-})
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+let liveSocket = new LiveSocket(&#34;/live&#34;, Socket, {longPollFallbackMs: 2500})
</span></span></span></code></pre></div><p>We can also remove the CSRF token from the rendered HTML in the root layout:</p>
<p><code>lib/cacheable_liveviews_web/components/layouts/root.html.heex</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="color:#f92672">--- a/lib/cacheable_liveviews_web/components/layouts/root.html.heex
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+++ b/lib/cacheable_liveviews_web/components/layouts/root.html.heex
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span><span style="color:#75715e">@@ -3,7 +3,6 @@
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   &lt;head&gt;
</span></span><span style="display:flex;"><span>     &lt;meta charset=&#34;utf-8&#34; /&gt;
</span></span><span style="display:flex;"><span>     &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1&#34; /&gt;
</span></span><span style="display:flex;"><span><span style="color:#f92672">-    &lt;meta name=&#34;csrf-token&#34; content={Plug.CSRFProtection.get_csrf_token()} /&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span>     &lt;title&gt;Cached private Liveview&lt;/title&gt;
</span></span><span style="display:flex;"><span>     &lt;link phx-track-static rel=&#34;stylesheet&#34; href={~p&#34;/assets/app.css&#34;} /&gt;
</span></span><span style="display:flex;"><span>     &lt;script defer phx-track-static type=&#34;text/javascript&#34; src={~p&#34;/assets/app.js&#34;}&gt;
</span></span></code></pre></div><p>You can also remove the <code>:protect_from_forgery</code> plug, if you don&rsquo;t use it otherwise:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="color:#f92672">--- a/lib/cacheable_liveviews_web/router.ex
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+++ b/lib/cacheable_liveviews_web/router.ex
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span><span style="color:#75715e">@@ -7,7 +7,6 @@ defmodule CacheableLiveviewsWeb.Router do
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     plug :accepts, [&#34;html&#34;]
</span></span><span style="display:flex;"><span>     plug :fetch_session
</span></span><span style="display:flex;"><span>     plug :fetch_live_flash
</span></span><span style="display:flex;"><span><span style="color:#f92672">-    plug :protect_from_forgery
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span>     plug :put_root_layout, html: {CacheableLiveviewsWeb.Layouts, :root}
</span></span><span style="display:flex;"><span>     plug :put_secure_browser_headers
</span></span><span style="display:flex;"><span>     plug CacheableLiveviewsWeb.Plug.SetASessionNoMatterWhat
</span></span></code></pre></div><p>It remains to configure caching. We&rsquo;ll do it a bit differently that the way proposed at the top of
this article. Although there are some Liveviews that we definitely want to cache, we would like to
have finer control on those we cache and those we don&rsquo;t cache.</p>
<p>Indeed some Liveviews are not really intended to be cached. In the following example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-elixir" data-lang="elixir"><span style="display:flex;"><span>live <span style="color:#e6db74">&#34;/resource/:resource_id&#34;</span>, <span style="color:#a6e22e">SomeProject.Index</span>, <span style="color:#e6db74">:index</span>
</span></span><span style="display:flex;"><span>live <span style="color:#e6db74">&#34;/resource/:resource_id/:edit&#34;</span>, <span style="color:#a6e22e">SomeProject.Index</span>, <span style="color:#e6db74">:edit</span>
</span></span></code></pre></div><p>we would like to cache the first, but not the second. Let&rsquo;s add a parameter to these routes we want
to cache:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-elixir" data-lang="elixir"><span style="display:flex;"><span>live_session <span style="color:#e6db74">:default</span> <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>  live <span style="color:#e6db74">&#34;/&#34;</span>, <span style="color:#a6e22e">MainLive.Index</span>, <span style="color:#e6db74">private</span>: %{<span style="color:#e6db74">cache</span>: <span style="color:#66d9ef">true</span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>According to the
<a href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.Router.html#live/4-options">documentation</a>,
<code>:private</code> is:</p>
<blockquote>
<p>an optional map of private data to put in the <em>plug connection</em>, for example:
<code>%{route_name: :foo, access: :user}</code>. The data will be available inside <code>conn.private</code> in plug
functions.</p>
</blockquote>
<p>Another issue is that inside a Liveview module, you have no access to the <code>%Plug.Conn{}</code> connection
and therefore we can&rsquo;t set the <code>cache-control</code> header. To bypass this issue, we&rsquo;ll use a
<a href="https://hexdocs.pm/plug/Plug.Conn.html#register_before_send/2">callback</a> to set the <code>cache-control</code>
header before caching the response.</p>
<p>Let&rsquo;s define a new caching pipeline:</p>
<p><code>lib/cacheable_liveviews_web/router.ex</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-elixir" data-lang="elixir"><span style="display:flex;"><span>pipeline <span style="color:#e6db74">:caching</span> <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>  plug <span style="color:#a6e22e">PlugHTTPCache</span>, <span style="color:#a6e22e">@caching_opts</span>
</span></span><span style="display:flex;"><span>  plug <span style="color:#a6e22e">CacheableLiveviewsWeb.Plug.CacheLiveviewResponse</span>, <span style="color:#ae81ff">60</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">60</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>Both <code>PlugHTTPCache</code> and <code>CacheableLiveviewsWeb.Plug.CacheLiveviewResponse</code> install a callback.
Keep in mind callbacks are executed in the reverse order in which they&rsquo;re installed. This means
the callback installed by <code>CacheableLiveviewsWeb.Plug.CacheLiveviewResponse</code> will be executed first.
Let&rsquo;s define it:</p>
<p><code>lib/cacheable_liveviews_web/plug/cache_liveview_response.ex</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-elixir" data-lang="elixir"><span style="display:flex;"><span><span style="color:#66d9ef">defmodule</span> <span style="color:#a6e22e">CacheableLiveviewsWeb.Plug.CacheLiveviewResponse</span> <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@behaviour</span> <span style="color:#a6e22e">Plug</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@impl</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> init(duration_second) <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>    duration_second
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@impl</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> call(conn, duration_second) <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Plug.Conn</span><span style="color:#f92672">.</span>register_before_send(conn, set_cache_control_header(duration_second))
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">defp</span> set_cache_control_header(duration_second) <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span>
</span></span><span style="display:flex;"><span>      %<span style="color:#a6e22e">Plug.Conn</span>{<span style="color:#e6db74">private</span>: %{<span style="color:#e6db74">cache</span>: <span style="color:#66d9ef">true</span>}} <span style="color:#f92672">=</span> conn <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">PlugCacheControl.Helpers</span><span style="color:#f92672">.</span>put_cache_control(conn, [<span style="color:#e6db74">:public</span>, <span style="color:#e6db74">s_maxage</span>: duration_second])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      conn <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>        conn
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>Notice that if the <code>cache: true</code> private option is not set, we return the <code>conn</code> without setting
cache-control headers.</p>
<p>Using such a callback can be used to set other headers, such as the
<a href="../ab-test-with-plug-http-cache/index.html"><code>vary</code> header</a> if you have A/B tested or
internationalized Liveviews for instance. In this case, you can use the process dictionary from
inside the Liveview&rsquo;s callbacks and read it in such a callback to set the value before caching.</p>
<p>Now caching should work ðŸ¥³</p>
<h2 id="limitations">Limitations</h2>
<p>When using
<a href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.Router.html#live_session/3">live sessions</a>,
the <em>static mount</em> is executed only when the websocket is initiated, that
is for the first visited page only. Be aware of that if you want to improve your SEO: you might
need an extra script to run after deployment, which visits all the pages you want to be cached before
search robots crawl it, otherwise they might be the first to visit them and take the performance hit
of the first rendering.</p>
<p>Phoenix Liveview requires a session to be set, which might not be the case if you get rid
of the now unnecessary <code>:protect_from_forgery</code> plug. In this case, just
<a href="https://github.com/tanguilp/cacheable_liveviews/blob/master/lib/cacheable_liveviews_web/plug/set_a_session_no_matter_what.ex">set a random cookie value</a>
and you&rsquo;re done.</p>
<h2 id="summary">Summary</h2>
<p>In this post we&rsquo;ve seen:</p>
<ul>
<li>why Liveview is not cacheable by default: the CSRF check is embedded in the rendered HTML and tied
to the user that visited the page first</li>
<li>what is a CSWSH attack and how we can defend ourselves against it</li>
<li>how it&rsquo;s relatively simple to disable CSRF check for Liveview, at the expense of disabling one
of the 2 security mecanisms protecting against CSWSH</li>
<li>how to configure <code>PlugHTTPCache</code> for Liveviews and selectively set cache control headers</li>
</ul>
<p>Caching Liveviews would also work with any CDN, in addition or without <code>PlugHTTPCache</code>.</p>
<p>So far we&rsquo;ve talked about the user session without considering that the pages we cache could contain
private data from this session. Is that possible that we could publicly cache private user data by
mistake and leak personal data?</p>
<p>Absolutely, but there is a way to cache such Liveviews anyway, without leaking private user data:
<a href="../caching-liveviews-part-2/index.html">Part 2: Publicly caching private Liveviews</a>.</p>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="https://svground.fr/tags/http-caching">HTTP caching</a></li>
					
					<li><a href="https://svground.fr/tags/elixir">Elixir</a></li>
					
					<li><a href="https://svground.fr/tags/liveview">Liveview</a></li>
					
				</ul>
			</nav>
			
			
		</div>
		</article>
</main>
<footer>
  <div style="display:flex"><a class="soc" href="https://github.com/tanguilp/" rel="me" title="GitHub"><i data-feather="github"></i></a>
    <a class="border"></a><a class="soc" href="https://www.linkedin.com/in/tanguil/" rel="me" title="Linkedin"><i data-feather="linkedin"></i></a>
    <a class="border"></a></div>
  <div class="footer-info">
    2024  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>


<script>
  feather.replace()
</script></div>
    </body>
</html>
